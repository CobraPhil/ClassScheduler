<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GBBC Class Schedule Generator</title>
    <style>
        /* Force color printing - preserve background colors when printing */
        @media print {
            * {
                print-color-adjust: exact !important;
                -webkit-print-color-adjust: exact !important;
                color-adjust: exact !important;
            }
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        .container {
            max-width: 1600px; /* Increased from 1200px for wider layout */
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .tabs {
            display: flex;
            background: #e9ecef;
        }
        .tab {
            flex: 1;
            padding: 15px 20px;
            text-align: center;
            cursor: pointer;
            background: #e9ecef;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            font-weight: 500;
        }
        .tab.active {
            background: white;
            border-bottom-color: #667eea;
            color: #667eea;
        }
        .tab:hover {
            background: #dee2e6;
        }
        .tab.active:hover {
            background: white;
        }
        .tab-content {
            display: none;
            padding: 30px;
        }
        .tab-content.active {
            display: block;
        }
        .upload-area {
            border: 3px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            transition: all 0.3s;
            cursor: pointer;
        }
        .upload-area:hover {
            border-color: #667eea;
            background-color: #f8f9ff;
        }
        .upload-area.dragover {
            border-color: #667eea;
            background-color: #f0f4ff;
        }
        .file-input {
            display: none;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s;
            margin: 10px 5px;
            display: inline-block;
            text-decoration: none;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn-secondary {
            background: #6c757d;
        }
        .btn-success {
            background: #28a745;
        }
        .btn-danger {
            background: #dc3545;
        }
        .btn-warning {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #333;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
        }
        .class-list {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            margin: 20px 0;
        }
        .class-item {
            display: flex;
            align-items: flex-start;
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s;
        }
        
        .class-sessions-container {
            display: flex;
            gap: 15px;
            margin-left: 15px;
            flex-wrap: wrap;
        }
        
        .session-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 120px;
        }
        
        .session-label {
            font-size: 11px;
            font-weight: bold;
            color: #666;
            text-align: center;
            margin-bottom: 3px;
        }
        
        .session-dropdown {
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 11px;
            background-color: white;
            min-width: 110px;
            font-weight: 500;
        }
        
        .session-dropdown:focus {
            border-color: #667eea;
            outline: none;
        }
        .class-item:hover {
            background-color: #f8f9fa;
        }
        .class-item:last-child {
            border-bottom: none;
        }
        .class-checkbox {
            margin-right: 15px;
            transform: scale(1.2);
        }
        .class-info {
            flex: 1;
        }
        .class-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        .class-details {
            color: #666;
            font-size: 14px;
        }
        .schedule-grid {
            margin: 20px 0;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            overflow: hidden;
        }
        .schedule-header {
            display: grid;
            grid-template-columns: 120px repeat(5, 1fr); /* Increased period column from 100px to 120px */
            background: #667eea;
            color: white;
            font-weight: bold;
        }
        .schedule-header div {
            padding: 15px 10px;
            text-align: center;
            border-right: 1px solid rgba(255,255,255,0.2);
        }
        .schedule-row {
            display: grid;
            grid-template-columns: 120px repeat(5, 1fr); /* Increased period column from 100px to 120px */
            border-bottom: 1px solid #dee2e6;
        }
        .schedule-row:nth-child(even) {
            background: #f8f9fa;
        }
        .period-label {
            padding: 15px 10px;
            background: #e9ecef;
            font-weight: bold;
            text-align: center;
            border-right: 1px solid #dee2e6;
            line-height: 1.2;
        }
        .period-label small {
            font-size: 10px;
            font-weight: normal;
            color: #666;
            display: block;
            margin-top: 2px;
        }
        .schedule-cell {
            padding: 8px;
            border-right: 1px solid #dee2e6;
            min-height: 50px; /* Reduced from 80px to 50px for compact display */
        }
        .class-block {
            background: transparent; /* Two-tone styling handled by JavaScript */
            color: white;
            padding: 6px; /* Reduced from 8px for more compact layout */
            border-radius: 5px;
            margin-bottom: 4px; /* Reduced from 5px */
            font-size: 12px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
        }
        .class-block:last-child {
            margin-bottom: 0;
        }
        .class-title {
            font-weight: bold;
            margin-bottom: 2px;
            white-space: nowrap; /* Prevent class names from wrapping */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ... if text is too long */
        }
        .class-teacher {
            opacity: 0.9;
            font-size: 11px;
        }
        .class-room {
            opacity: 0.8;
            font-size: 10px;
            font-style: italic;
            margin-top: 2px;
        }
        .class-students {
            opacity: 0.9;
            font-size: 9px;
            color: white;
            margin-top: 1px;
        }
        .alert {
            padding: 15px 20px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid;
        }
        .alert-success {
            background-color: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        .alert-error {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
        .alert-info {
            background-color: #d7f3ff;
            border-color: #17a2b8;
            color: #0c5460;
        }
        .alert-warning {
            background-color: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-label {
            opacity: 0.9;
            font-size: 14px;
        }
        .loading {
            text-align: center;
            padding: 40px;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .conflict-info {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        .conflict-list {
            margin: 10px 0;
            padding-left: 20px;
        }
        .error-item {
            display: flex;
            align-items: flex-start;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid;
        }
        .error-item.critical {
            background-color: #f8d7da;
            border-left-color: #dc3545;
            color: #721c24;
        }
        .error-item.warning {
            background-color: #fff3cd;
            border-left-color: #ffc107;
            color: #856404;
        }
        .error-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
        }
        .error-indicator.critical {
            background-color: #dc3545;
        }
        .error-indicator.warning {
            background-color: #ffc107;
        }
        
        /* Drag and Drop Styles */
        .draggable-class {
            transition: all 0.2s ease;
        }
        
        .draggable-class:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .multi-session-class {
            opacity: 0.9;
        }
        
        .multi-session-class:hover {
            opacity: 1;
        }
        
        /* Drop zone styles */
        .drop-zone {
            transition: all 0.2s ease;
            min-height: 60px;
        }
        
        .drop-zone.valid-drop {
            background-color: rgba(76, 175, 80, 0.1);
            border: 2px dashed #4CAF50;
            animation: pulse-valid 1s infinite;
        }
        
        .drop-zone.invalid-drop {
            background-color: rgba(244, 67, 54, 0.1);
            border: 2px dashed #f44336;
            opacity: 0.5;
        }
        
        .drop-zone.current-slot {
            background-color: rgba(255, 193, 7, 0.2);
            border: 2px solid #FFC107;
        }
        
        .drop-zone.drag-hover {
            background-color: rgba(33, 150, 243, 0.2);
            border: 2px solid #2196F3;
            transform: scale(1.02);
        }
        
        /* Animations */
        @keyframes pulse-valid {
            0% { border-color: #4CAF50; }
            50% { border-color: #8BC34A; }
            100% { border-color: #4CAF50; }
        }
        
        /* Room conflict indicator */
        .room-indicator.conflict {
            color: #ff4444 !important;
            font-weight: bold;
        }
        
        /* Dragging state */
        .dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        
        /* Visual feedback for different class types */
        .class-block.draggable-class::before {
            content: "‚Üï";
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .class-block.draggable-class:hover::before {
            opacity: 0.7;
        }
        
        /* Multi-session individual session styling */
        .class-block.multi-session-session::after {
            content: "üìå";
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>GBBC Class Schedule Generator</h1>
            <p>Generate conflict-free weekly class schedules with room assignments</p>
        </div>
        
        <div class="tabs">
            <div class="tab active" onclick="showTab('upload')">1. Upload CSV</div>
            <div class="tab" onclick="showTab('select')">2. Select Classes</div>
            <div class="tab" onclick="showTab('schedule')">3. Generate Schedule</div>
        </div>
        
        <!-- Tab 1: Upload CSV -->
        <div id="upload" class="tab-content active">
            <h2>Upload ClassList.csv</h2>
            <p>Upload a ClassList.csv file exported from ThinkWave containing class enrollment data with students, teachers, and course details.</p>
            
            <div class="upload-area" onclick="document.getElementById('csvFile').click()">
                <h3>üìÅ Click to select CSV file</h3>
                <p>or drag and drop your ClassList.csv file here</p>
                <input type="file" id="csvFile" class="file-input" accept=".csv">
            </div>
            
            <button class="btn" onclick="uploadCSV()" id="uploadBtn" disabled>Process CSV</button>
            
            <div id="uploadLog" class="log" style="display: none;"></div>
        </div>
        
        <!-- Tab 2: Select Classes -->
        <div id="select" class="tab-content">
            <h2>Select Classes</h2>
            <p>Review and select which classes to include in your schedule.</p>
            
            <div class="stats-grid" id="classStats" style="display: none;">
                <div class="stat-card">
                    <div class="stat-number" id="totalClasses">0</div>
                    <div class="stat-label">Total Classes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="selectedClasses">0</div>
                    <div class="stat-label">Selected Classes</div>
                </div>
            </div>
            
            <div style="margin: 20px 0;">
                <button class="btn btn-secondary" onclick="selectAll()">Select All</button>
                <button class="btn btn-secondary" onclick="selectNone()">Select None</button>
                <button class="btn btn-warning" onclick="importLastSchedule()" id="importBtn" style="display: none;">Import Last Schedule</button>
                <button class="btn" onclick="confirmSelection()" id="confirmBtn" disabled>Confirm Selection</button>
            </div>
            
            <div id="classList" class="class-list"></div>
        </div>
        
        <!-- Tab 3: Generate Schedule -->
        <div id="schedule" class="tab-content">
            <h2>Generate Class Schedule</h2>
            <p>Generate a conflict-free weekly schedule with room assignments.</p>
            
            <div style="margin: 20px 0;">
                <button class="btn" onclick="generateSchedule()" id="generateBtn" disabled>Generate Schedule</button>
                <button class="btn btn-warning" onclick="generateSchedule(true)" id="generateWithP7Btn" style="display: none;">Try with Period 7</button>
                <button class="btn btn-success" onclick="exportPDF()" id="exportBtn" style="display: none;">Export Schedule</button>
            </div>
            
            <div id="conflictInfo" class="conflict-info" style="display: none;">
                <h4>‚ö†Ô∏è Scheduling Conflicts Detected</h4>
                <p>Some classes could not be scheduled without conflicts. You can:</p>
                <ul>
                    <li>Try including Period 7 (normally reserved)</li>
                    <li>Manually adjust class selections</li>
                    <li>Review the conflict details below</li>
                </ul>
                <div id="conflictDetails" class="conflict-list"></div>
            </div>
            
            <div id="schedulingErrors" class="conflict-info" style="display: none;">
                <h4>üî¥ Critical Scheduling Issues</h4>
                <p>The following classes could not be scheduled at all due to conflicts:</p>
                <div id="errorDetails" class="conflict-list"></div>
            </div>
            
            <div id="manualWarnings" class="conflict-info" style="display: none;">
                <h4>üü° Manual Assignment Conflicts</h4>
                <p>The following classes were scheduled successfully but not at your manually specified settings:</p>
                <div id="warningDetails" class="conflict-list"></div>
            </div>
            
            <div id="scheduleStats" class="stats-grid" style="display: none;"></div>
            <div id="scheduleDisplay" style="display: none;">
                <div class="schedule-grid">
                    <div class="schedule-header">
                        <div>Period</div>
                        <div>Monday</div>
                        <div>Tuesday</div>
                        <div>Wednesday</div>
                        <div>Thursday</div>
                        <div>Friday</div>
                    </div>
                    <div id="scheduleRows"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentClasses = [];
        let selectedClassNames = new Set();
        let currentSchedule = null;
        let classSessionAssignments = {}; // Track manual session assignments (day, period, room per session)
        let classColors = {}; // Track color assignments for each class
        
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            document.querySelector(`[onclick="showTab('${tabName}')"]`).classList.add('active');
            
            // If navigating to schedule tab, check if schedule should be cleared
            if (tabName === 'schedule') {
                checkScheduleStatus();
            }
        }
        
        async function checkScheduleStatus() {
            // Check if the server still has a schedule
            // If not, clear the frontend display
            try {
                const response = await fetch('/get_schedule_status');
                if (response.ok) {
                    const data = await response.json();
                    if (!data.has_schedule) {
                        // Server has no schedule, clear the frontend
                        clearScheduleDisplay();
                    }
                }
            } catch (error) {
                console.log('Could not check schedule status:', error);
                // On error, be safe and clear the display
                clearScheduleDisplay();
            }
        }
        
        function clearScheduleDisplay() {
            // Clear the schedule display
            currentSchedule = null;
            document.getElementById('scheduleRows').innerHTML = '';
            document.getElementById('scheduleResult').style.display = 'none';
            document.getElementById('exportBtn').style.display = 'none';
            document.getElementById('generateBtn').disabled = selectedClassNames.size === 0;
            console.log('Schedule display cleared');
        }
        
        function showAlert(message, type = 'info') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            const activeTab = document.querySelector('.tab-content.active');
            activeTab.insertBefore(alertDiv, activeTab.firstChild);
            
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.parentNode.removeChild(alertDiv);
                }
            }, 5000);
        }
        
        function updateLog(message) {
            const log = document.getElementById('uploadLog');
            log.style.display = 'block';
            log.textContent += message + '\n';
            log.scrollTop = log.scrollHeight;
        }
        
        // File upload handling
        document.getElementById('csvFile').addEventListener('change', function() {
            const file = this.files[0];
            if (file) {
                document.getElementById('uploadBtn').disabled = false;
                updateLog(`Selected file: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`);
            }
        });
        
        // Drag and drop
        const uploadArea = document.querySelector('.upload-area');
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', function() {
            this.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            this.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].name.endsWith('.csv')) {
                document.getElementById('csvFile').files = files;
                document.getElementById('uploadBtn').disabled = false;
                updateLog(`Dropped file: ${files[0].name}`);
            } else {
                showAlert('Please drop a CSV file', 'error');
            }
        });
        
        async function uploadCSV() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                showAlert('Please select a CSV file', 'error');
                return;
            }
            
            const formData = new FormData();
            formData.append('csv_file', file);
            
            updateLog('Processing CSV...');
            document.getElementById('uploadBtn').disabled = true;
            
            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    updateLog(`‚úì Found ${result.classes_found} classes`);
                    updateLog('‚úì Processing complete!');
                    
                    currentClasses = result.classes;
                    populateClassList();
                    showTab('select');
                    showAlert('CSV processed successfully!', 'success');
                } else {
                    updateLog(`‚úó Error: ${result.error}`);
                    showAlert(result.error, 'error');
                }
            } catch (error) {
                updateLog(`‚úó Network error: ${error.message}`);
                showAlert('Network error occurred', 'error');
            }
            
            document.getElementById('uploadBtn').disabled = false;
        }
        
        async function checkSavedSchedule() {
            // Check if there's a saved schedule and show/hide import button
            try {
                const response = await fetch('/check_saved_schedule');
                if (response.ok) {
                    const data = await response.json();
                    const importBtn = document.getElementById('importBtn');
                    if (data.has_saved_schedule) {
                        importBtn.style.display = 'inline-block';
                    } else {
                        importBtn.style.display = 'none';
                    }
                }
            } catch (error) {
                console.log('Could not check saved schedule:', error);
                document.getElementById('importBtn').style.display = 'none';
            }
        }
        
        function populateClassList() {
            const classList = document.getElementById('classList');
            classList.innerHTML = '';
            
            selectedClassNames.clear();
            
            // Check for saved schedule when populating class list
            checkSavedSchedule();
            
            currentClasses.forEach((cls, index) => {
                const item = document.createElement('div');
                item.className = 'class-item';
                
                // Determine number of sessions based on units
                const units = parseInt(cls.units) || 4;
                let numSessions;
                if (units <= 4) numSessions = 1;
                else if (units <= 8) numSessions = 2;
                else numSessions = 3;
                
                // Determine default room assignment
                const courseName = cls.name.toUpperCase();
                let defaultRoom = 'Open';
                
                // Computer classes (GECO) and ESL classes (GELA) default to Computer Lab
                if (courseName.includes('GECO') || courseName.includes('GELA')) {
                    defaultRoom = 'Computer Lab';
                }
                
                // Initialize class session assignments
                if (!classSessionAssignments[cls.name]) {
                    classSessionAssignments[cls.name] = [];
                    for (let i = 0; i < numSessions; i++) {
                        classSessionAssignments[cls.name].push({
                            day: 'Open',
                            period: 'Open', 
                            room: defaultRoom
                        });
                    }
                }
                
                // Generate sessions HTML  
                let sessionsHTML = '';
                for (let sessionIndex = 0; sessionIndex < numSessions; sessionIndex++) {
                    const sessionNum = sessionIndex + 1;
                    const currentSession = classSessionAssignments[cls.name][sessionIndex];
                    
                    sessionsHTML += `
                        <div class="session-group">
                            <div class="session-label">Class ${sessionNum}</div>
                            <select class="session-dropdown" onchange="updateClassSession('${cls.name}', ${sessionIndex}, 'day', this.value)">
                                <option value="Open" ${currentSession.day === 'Open' ? 'selected' : ''}>Open</option>
                                <option value="Monday" ${currentSession.day === 'Monday' ? 'selected' : ''}>Monday</option>
                                <option value="Tuesday" ${currentSession.day === 'Tuesday' ? 'selected' : ''}>Tuesday</option>
                                <option value="Wednesday" ${currentSession.day === 'Wednesday' ? 'selected' : ''}>Wednesday</option>
                                <option value="Thursday" ${currentSession.day === 'Thursday' ? 'selected' : ''}>Thursday</option>
                                <option value="Friday" ${currentSession.day === 'Friday' ? 'selected' : ''}>Friday</option>
                            </select>
                            <select class="session-dropdown" onchange="updateClassSession('${cls.name}', ${sessionIndex}, 'period', this.value)">
                                <option value="Open" ${currentSession.period === 'Open' || currentSession.period == null ? 'selected' : ''}>Open</option>
                                <option value="1" ${currentSession.period == '1' || currentSession.period == 1 ? 'selected' : ''}>Period 1 (7:00am-7:50am)</option>
                                <option value="2" ${currentSession.period == '2' || currentSession.period == 2 ? 'selected' : ''}>Period 2 (8:00am-8:50am)</option>
                                <option value="4" ${currentSession.period == '4' || currentSession.period == 4 ? 'selected' : ''}>Period 4 (9:40am-10:30am)</option>
                                <option value="5" ${currentSession.period == '5' || currentSession.period == 5 ? 'selected' : ''}>Period 5 (10:40am-11:30am)</option>
                                <option value="6" ${currentSession.period == '6' || currentSession.period == 6 ? 'selected' : ''}>Period 6 (11:40am-12:30pm)</option>
                                <option value="7" ${currentSession.period == '7' || currentSession.period == 7 ? 'selected' : ''}>Period 7 (12:40pm-1:30pm)</option>
                                <option value="11" ${currentSession.period == '11' || currentSession.period == 11 ? 'selected' : ''}>Period 7b (1:00pm-3:00pm)</option>
                                <option value="8" ${currentSession.period == '8' || currentSession.period == 8 ? 'selected' : ''}>Period 8 (5:30pm-6:20pm)</option>
                                <option value="9" ${currentSession.period == '9' || currentSession.period == 9 ? 'selected' : ''}>Period 9 (6:30pm-7:20pm)</option>
                                <option value="10" ${currentSession.period == '10' || currentSession.period == 10 ? 'selected' : ''}>Period 10 (7:30pm-8:20pm)</option>
                            </select>
                            <select class="session-dropdown" onchange="updateClassSession('${cls.name}', ${sessionIndex}, 'room', this.value)">
                                <option value="Open" ${currentSession.room === 'Open' ? 'selected' : ''}>Open</option>
                                <option value="Computer Lab" ${currentSession.room === 'Computer Lab' ? 'selected' : ''}>Computer Lab</option>
                                <option value="Chapel" ${currentSession.room === 'Chapel' ? 'selected' : ''}>Chapel</option>
                                <option value="Classroom 2" ${currentSession.room === 'Classroom 2' ? 'selected' : ''}>Classroom 2</option>
                                <option value="Classroom 4" ${currentSession.room === 'Classroom 4' ? 'selected' : ''}>Classroom 4</option>
                                <option value="Classroom 5" ${currentSession.room === 'Classroom 5' ? 'selected' : ''}>Classroom 5</option>
                                <option value="Classroom 6" ${currentSession.room === 'Classroom 6' ? 'selected' : ''}>Classroom 6</option>
                            </select>
                        </div>
                    `;
                }
                
                item.innerHTML = `
                    <input type="checkbox" class="class-checkbox" 
                           onchange="toggleClass('${cls.name}', this.checked)">
                    <div class="class-info">
                        <div class="class-name">${cls.name}</div>
                        <div class="class-details">${cls.teacher} ‚Ä¢ ${cls.student_count} students ‚Ä¢ ${cls.units} units</div>
                    </div>
                    <div class="class-sessions-container">
                        ${sessionsHTML}
                    </div>
                `;
                
                classList.appendChild(item);
            });
            
            updateClassStats();
            document.getElementById('classStats').style.display = 'grid';
            document.getElementById('confirmBtn').disabled = false;
        }
        
        function toggleClass(className, selected) {
            if (selected) {
                selectedClassNames.add(className);
            } else {
                selectedClassNames.delete(className);
            }
            updateClassStats();
        }
        
        function updateClassStats() {
            document.getElementById('totalClasses').textContent = currentClasses.length;
            document.getElementById('selectedClasses').textContent = selectedClassNames.size;
        }
        
        function updateClassSession(className, sessionIndex, field, value) {
            if (!classSessionAssignments[className]) {
                classSessionAssignments[className] = [];
            }
            
            // DEBUG: Check if we're trying to update a session beyond expected range
            if (sessionIndex >= classSessionAssignments[className].length) {
                console.warn(`DEBUG: Attempting to update session ${sessionIndex} for ${className}, but class only has ${classSessionAssignments[className].length} sessions`);
                console.trace("Stack trace for out-of-range session update:");
                return; // Don't add extra sessions
            }
            
            // Update the specific field
            if (field === 'period' && value !== 'Open') {
                // Store period as integer for backend consistency
                classSessionAssignments[className][sessionIndex][field] = parseInt(value);
            } else {
                // Store other fields as strings
                classSessionAssignments[className][sessionIndex][field] = value;
            }
            
            console.log('Session assignments:', classSessionAssignments);
        }
        
        function selectAll() {
            document.querySelectorAll('.class-checkbox').forEach(cb => {
                cb.checked = true;
                const className = cb.parentNode.querySelector('.class-name').textContent;
                selectedClassNames.add(className);
            });
            updateClassStats();
        }
        
        function selectNone() {
            document.querySelectorAll('.class-checkbox').forEach(cb => {
                cb.checked = false;
            });
            selectedClassNames.clear();
            updateClassStats();
        }
        
        async function confirmSelection() {
            if (selectedClassNames.size === 0) {
                showAlert('Please select at least one class', 'error');
                return;
            }
            
            try {
                const response = await fetch('/set_selection', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        selected_classes: Array.from(selectedClassNames),
                        session_assignments: classSessionAssignments
                    })
                });
                
                const result = await response.json();

                // Clear error panels and any previous room conflict summary now that selection is saved
                const schedulingErrors = document.getElementById('schedulingErrors');
                const errorDetails = document.getElementById('errorDetails');
                const manualWarnings = document.getElementById('manualWarnings');
                const warningDetails = document.getElementById('warningDetails');
                if (schedulingErrors) { schedulingErrors.style.display = 'none'; errorDetails.innerHTML = ''; }
                if (manualWarnings) { manualWarnings.style.display = 'none'; warningDetails.innerHTML = ''; }
                const existingRoomSummary = document.getElementById('roomConflictSummary');
                if (existingRoomSummary) existingRoomSummary.remove();
                
                if (result.success) {
                    showAlert(`${result.selected_count} classes selected`, 'success');
                    document.getElementById('generateBtn').disabled = false;
                    showTab('schedule');
                } else {
                    showAlert(result.error, 'error');
                }
            } catch (error) {
                showAlert('Network error occurred', 'error');
            }
        }
        
        async function importLastSchedule() {
            try {
                const response = await fetch('/load_saved_schedule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Restore selected classes
                    selectedClassNames.clear();
                    result.selected_classes.forEach(className => {
                        selectedClassNames.add(className);
                    });
                    
                    // Restore session assignments
                    classSessionAssignments = result.session_assignments || {};
                    
                    // Update the UI to reflect the loaded data
                    updateUIFromLoadedData();
                    
                    const timestamp = new Date(result.timestamp).toLocaleString();
                    showAlert(`Schedule imported successfully! (Saved: ${timestamp})`, 'success');
                } else {
                    showAlert(result.error, 'error');
                }
            } catch (error) {
                showAlert('Network error occurred', 'error');
            }
        }
        
        function updateUIFromLoadedData() {
            // Update checkboxes for selected classes
            document.querySelectorAll('.class-checkbox').forEach(cb => {
                const className = cb.parentNode.querySelector('.class-name').textContent;
                cb.checked = selectedClassNames.has(className);
            });
            
            // Update session dropdowns
            for (const [className, sessions] of Object.entries(classSessionAssignments)) {
                sessions.forEach((session, sessionIndex) => {
                    // Find dropdowns by class name and session index using data attributes
                    const classContainer = Array.from(document.querySelectorAll('.class-item')).find(item => {
                        const nameElement = item.querySelector('.class-name');
                        return nameElement && nameElement.textContent === className;
                    });
                    
                    if (classContainer) {
                        const dropdowns = classContainer.querySelectorAll('.session-dropdown');
                        const sessionDropdowns = Array.from(dropdowns).slice(sessionIndex * 3, (sessionIndex + 1) * 3);
                        
                        if (sessionDropdowns.length >= 3) {
                            // Update day dropdown (first in group)
                            sessionDropdowns[0].value = session.day || 'Open';
                            
                            // Update period dropdown (second in group) - ensure string conversion
                            sessionDropdowns[1].value = session.period?.toString() || 'Open';
                            
                            // Update room dropdown (third in group)
                            sessionDropdowns[2].value = session.room || 'Open';
                        }
                    }
                });
            }
            
            // Update stats
            updateClassStats();
        }
        
        function displaySchedulingErrors(errors, warnings) {
            const schedulingErrors = document.getElementById('schedulingErrors');
            const errorDetails = document.getElementById('errorDetails');
            const manualWarnings = document.getElementById('manualWarnings');
            const warningDetails = document.getElementById('warningDetails');
            
            // Handle critical errors (red indicator)
            if (errors && errors.length > 0) {
                let errorHTML = '<div>';
                
                errors.forEach(error => {
                    const conflicts = error.conflicts;
                    let conflictSummary = [];
                    
                    if (conflicts.student_conflicts > 0) {
                        conflictSummary.push(`${conflicts.student_conflicts} student conflict${conflicts.student_conflicts > 1 ? 's' : ''}`);
                    }
                    if (conflicts.teacher_conflicts > 0) {
                        conflictSummary.push(`${conflicts.teacher_conflicts} teacher conflict${conflicts.teacher_conflicts > 1 ? 's' : ''}`);
                    }
                    if (conflicts.room_conflicts > 0) {
                        conflictSummary.push(`${conflicts.room_conflicts} room conflict${conflicts.room_conflicts > 1 ? 's' : ''}`);
                    }
                    
                    let conflictText = conflictSummary.length > 0 ? conflictSummary.join(', ') : 'scheduling conflicts';
                    
                    errorHTML += `
                        <div class="error-item critical">
                            <div class="error-indicator critical">!</div>
                            <div>
                                <strong>${error.class_name}</strong> (${error.teacher})<br>
                                <small>${error.student_count} students ‚Ä¢ ${conflictText}</small>`;
                    
                    if (error.requested_slot) {
                        errorHTML += `<br><small><em>Requested: ${error.requested_slot}</em></small>`;
                    }
                    
                    // Add specific conflict details with enhanced student conflict display
                    if (conflicts.details && conflicts.details.length > 0) {
                        let formattedDetails = conflicts.details.map(detail => {
                            // Check if this is a student conflict with student names
                            const studentMatch = detail.match(/student conflict with (.+) \(students: (.+)\)/);
                            if (studentMatch) {
                                const conflictClass = studentMatch[1];
                                const students = studentMatch[2];
                                return `student conflict with <strong>${conflictClass}</strong><br>&nbsp;&nbsp;‚Üí Conflicting students: <em>${students}</em>`;
                            }
                            return detail;
                        });
                        errorHTML += '<br><small>Issues:<br>' + formattedDetails.join('<br>') + '</small>';
                    }
                    
                    errorHTML += '</div></div>';
                });
                
                errorHTML += '</div>';
                errorDetails.innerHTML = errorHTML;
                schedulingErrors.style.display = 'block';
            } else {
                schedulingErrors.style.display = 'none';
            }
            
            // Handle manual assignment warnings (yellow indicator)
            if (warnings && warnings.length > 0) {
                let warningHTML = '<div>';
                
                warnings.forEach(warning => {
                    const conflicts = warning.conflicts;
                    let conflictSummary = [];
                    
                    if (conflicts.student_conflicts > 0) {
                        conflictSummary.push(`${conflicts.student_conflicts} student conflict${conflicts.student_conflicts > 1 ? 's' : ''}`);
                    }
                    if (conflicts.teacher_conflicts > 0) {
                        conflictSummary.push(`${conflicts.teacher_conflicts} teacher conflict${conflicts.teacher_conflicts > 1 ? 's' : ''}`);
                    }
                    if (conflicts.room_conflicts > 0) {
                        conflictSummary.push(`${conflicts.room_conflicts} room conflict${conflicts.room_conflicts > 1 ? 's' : ''}`);
                    }
                    
                    let conflictText = conflictSummary.length > 0 ? conflictSummary.join(', ') : 'scheduling conflicts';
                    
                    warningHTML += `
                        <div class="error-item warning">
                            <div class="error-indicator warning">‚ö†</div>
                            <div>
                                <strong>${warning.class_name}</strong> (${warning.teacher})<br>
                                <small>${warning.student_count} students ‚Ä¢ ${conflictText}</small>
                                <br><small><em>Requested: ${warning.requested_slot} ‚Üí Auto-scheduled elsewhere</em></small>`;
                    
                    // Add specific conflict details with enhanced student conflict display
                    if (conflicts.details && conflicts.details.length > 0) {
                        let formattedDetails = conflicts.details.map(detail => {
                            // Check if this is a student conflict with student names
                            const studentMatch = detail.match(/student conflict with (.+) \(students: (.+)\)/);
                            if (studentMatch) {
                                const conflictClass = studentMatch[1];
                                const students = studentMatch[2];
                                return `student conflict with <strong>${conflictClass}</strong><br>&nbsp;&nbsp;‚Üí Conflicting students: <em>${students}</em>`;
                            }
                            return detail;
                        });
                        warningHTML += '<br><small>Issues:<br>' + formattedDetails.join('<br>') + '</small>';
                    }
                    
                    warningHTML += '</div></div>';
                });
                
                warningHTML += '</div>';
                warningDetails.innerHTML = warningHTML;
                manualWarnings.style.display = 'block';
            } else {
                manualWarnings.style.display = 'none';
            }
        }
        
        async function generateSchedule(usePeriod7 = false) {
            const scheduleDisplay = document.getElementById('scheduleDisplay');
            const conflictInfo = document.getElementById('conflictInfo');
            const generateWithP7Btn = document.getElementById('generateWithP7Btn');
            const exportBtn = document.getElementById('exportBtn');
            const schedulingErrors = document.getElementById('schedulingErrors');
            const errorDetails = document.getElementById('errorDetails');
            const manualWarnings = document.getElementById('manualWarnings');
            const warningDetails = document.getElementById('warningDetails');
            
            // Hide previous results
            scheduleDisplay.style.display = 'none';
            conflictInfo.style.display = 'none';
            // Clear any prior errors/warnings and conflict summary
            if (schedulingErrors) { schedulingErrors.style.display = 'none'; errorDetails.innerHTML = ''; }
            if (manualWarnings) { manualWarnings.style.display = 'none'; warningDetails.innerHTML = ''; }
            const existingRoomSummary = document.getElementById('roomConflictSummary');
            if (existingRoomSummary) existingRoomSummary.remove();
            generateWithP7Btn.style.display = 'none';
            exportBtn.style.display = 'none';
            
            // Show loading
            const scheduleRows = document.getElementById('scheduleRows');
            scheduleRows.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Generating conflict-free schedule...</p>
                </div>
            `;
            scheduleDisplay.style.display = 'block';
            
            try {
                // Create a timeout controller for the fetch request
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                
                const response = await fetch('/generate_schedule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        use_period_7: usePeriod7
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    // Store class colors for use throughout the interface
                    classColors = result.class_colors || {};
                    displaySchedule(result.schedule, result.stats);
                    // Always re-render errors/warnings so old ones are cleared
                    const errs = result.scheduling_errors || [];
                    const warns = result.manual_assignment_warnings || [];
                    displaySchedulingErrors(errs, warns);
                    if (result.partial_schedule && (errs.length > 0 || warns.length > 0)) {
                        let message = '';
                        let alertType = 'success';
                        if (errs.length > 0) { message = `${errs.length} class(es) could not be scheduled`; alertType = 'error'; }
                        if (warns.length > 0) {
                            if (message) { message += ` and ${warns.length} manual assignment(s) were ignored`; }
                            else { message = `${warns.length} manual assignment(s) were ignored due to conflicts`; alertType = 'warning'; }
                        }
                        showAlert(`Partial schedule generated - ${message}`, alertType);
                    } else {
                        showAlert('Schedule generated successfully!', 'success');
                    }
                    exportBtn.style.display = 'inline-block';
                } else {
                    scheduleDisplay.style.display = 'none';
                    
                    if (result.can_try_period_7) {
                        conflictInfo.style.display = 'block';
                        generateWithP7Btn.style.display = 'inline-block';
                        
                        const conflictDetails = document.getElementById('conflictDetails');
                        conflictDetails.innerHTML = '<h5>Unscheduled Classes:</h5>';
                        result.unscheduled.forEach(item => {
                            conflictDetails.innerHTML += `<p><strong>${item.class.Class}</strong> - ${item.conflicts.join(', ')}</p>`;
                        });
                    } else {
                        showAlert('Could not generate conflict-free schedule even with Period 7. Manual adjustment required.', 'error');
                    }
                }
            } catch (error) {
                scheduleDisplay.style.display = 'none';
                
                if (error.name === 'AbortError') {
                    showAlert('Request timed out - schedule generation took too long. Please try again.', 'error');
                } else if (error.message.includes('Server error:')) {
                    showAlert(error.message, 'error');
                } else if (error.message.includes('Failed to fetch')) {
                    showAlert('Network connection error - please check your connection and try again.', 'error');
                } else {
                    showAlert(`Error: ${error.message}`, 'error');
                }
                
                console.error('Schedule generation error:', error);
            }
        }
        
        function displaySchedule(schedule, stats) {
            const scheduleRows = document.getElementById('scheduleRows');
            const scheduleStats = document.getElementById('scheduleStats');
            
            // Display stats
            scheduleStats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${stats.total_classes}</div>
                    <div class="stat-label">Total Classes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.scheduled_classes}</div>
                    <div class="stat-label">Scheduled Classes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.unscheduled_classes}</div>
                    <div class="stat-label">Unscheduled Classes</div>
                </div>
            `;
            scheduleStats.style.display = 'grid';
            
            // Display schedule grid
            scheduleRows.innerHTML = '';
            currentSchedule = schedule;
            
            const periods = [1, 2, 3, 4, 5, 6, 7, 11, 8, 9, 10];  // Period 7b moved after Period 7
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

            // Build a room conflict map for quick lookups
            const conflictMap = new Map();
            days.forEach(d => {
                if (!schedule[d]) return;
                periods.forEach(p => {
                    const key = `${d}-${p}`;
                    const rc = new Map();
                    const classes = schedule[d][p] || [];
                    classes.forEach(ci => {
                        const room = ci.room || 'TBD';
                        if (room === 'Open' || room === 'TBD') return;
                        const entry = rc.get(room) || { count: 0, classes: [] };
                        entry.count += 1;
                        entry.classes.push(ci.Class);
                        rc.set(room, entry);
                    });
                    conflictMap.set(key, rc);
                });
            });
            
            periods.forEach(period => {
                const row = document.createElement('div');
                row.className = 'schedule-row';
                
                let periodLabel = period === 11 ? 'Period 7b' : `Period ${period}`;
                let periodTime = '';
                
                // Add period times
                switch(period) {
                    case 1: periodTime = '7:00am-7:50am'; break;
                    case 2: periodTime = '8:00am-8:50am'; break;
                    case 3: periodTime = '9:00am-9:30am (Chapel)'; break;
                    case 4: periodTime = '9:40am-10:30am'; break;
                    case 5: periodTime = '10:40am-11:30am'; break;
                    case 6: periodTime = '11:40am-12:30pm'; break;
                    case 7: periodTime = '12:40pm-1:30pm'; break;
                    case 8: periodTime = '5:30pm-6:20pm'; break;
                    case 9: periodTime = '6:30pm-7:20pm'; break;
                    case 10: periodTime = '7:30pm-8:20pm'; break;
                    case 11: periodTime = '1:00pm-3:00pm'; break;
                }
                
                periodLabel = `${periodLabel}<br><small>${periodTime}</small>`;
                
                row.innerHTML = `<div class="period-label">${periodLabel}</div>`;
                
                days.forEach(day => {
                    const cell = document.createElement('div');
                    cell.className = 'schedule-cell drop-zone';
                    cell.dataset.day = day;
                    cell.dataset.period = period;
                    
                    if (schedule[day] && schedule[day][period]) {
                        schedule[day][period].forEach((classInfo, sessionIndex) => {
                            const classBlock = document.createElement('div');
                            
                            // All individual sessions are now draggable
                            classBlock.className = 'class-block draggable-class';
                            classBlock.draggable = true;
                            classBlock.dataset.className = classInfo.Class;
                            classBlock.dataset.sessionIndex = classInfo.sessionIndex || 0; // Use sessionIndex from backend
                            classBlock.dataset.currentDay = day;
                            classBlock.dataset.currentPeriod = period;
                            classBlock.style.cursor = 'grab';
                            
                            // Determine class frequency for visual indicator
                            const classUnits = classInfo.Units || 8;
                            const frequency = getClassFrequency(classUnits);
                            
                            
                            // All sessions are individually movable
                            classBlock.title = `${classInfo.Class} - Session ${(classInfo.sessionIndex || 0) + 1} - Drag to move this session`;
                            classBlock.classList.add('movable-session');
                            
                            // Use room information from backend
                            const roomName = classInfo.room || 'TBD';
                            
                            // Apply two-tone color styling
                            const classColorData = classColors[classInfo.Class] || {
                                header: '#667eea',
                                body: '#8a9bf2'
                            };
                            
                            // Use abbreviated teacher name if available, otherwise abbreviate on frontend
                            let teacherName = classInfo.teacher_abbreviated || classInfo.Teacher;
                            if (!classInfo.teacher_abbreviated && classInfo.Teacher && classInfo.Teacher.includes(',')) {
                                const parts = classInfo.Teacher.split(',');
                                if (parts.length >= 2) {
                                    const lastName = parts[0].trim();
                                    const firstName = parts[1].trim();
                                    if (firstName) {
                                        teacherName = `${lastName}, ${firstName[0]}.`;
                                    }
                                }
                            }
                            
                            // Use abbreviated room name if available, otherwise abbreviate on frontend
                            let roomNameAbbrev = classInfo.room_abbreviated || roomName;
                            if (!classInfo.room_abbreviated && roomName) {
                                roomNameAbbrev = roomName.replace('Classroom', 'Room').replace('classroom', 'Room').replace('class', 'Class');
                            }
                            
                            // Add visual indicator for all movable classes
                            const multiSessionIndicator = '<span style="float: right; font-size: 8px; opacity: 0.8;">üìå</span>';
                            
                            // Detect room conflict for this exact slot/room
                            let hasRoomConflict = false;
                            if (roomName && roomName !== 'Open' && roomName !== 'TBD') {
                                const key = `${day}-${period}`;
                                const roomCounts = conflictMap.get(key);
                                const entry = roomCounts ? roomCounts.get(roomName) : null;
                                hasRoomConflict = !!(entry && entry.count > 1);
                            }

                            classBlock.innerHTML = `
                                <div class="class-title" style="background-color: ${classColorData.header}; padding: 3px 6px; margin: -6px -6px 0 -6px; border-radius: 5px 5px 0 0; color: white;" title="${classInfo.Class}">
                                    ${classInfo.Class}${multiSessionIndicator}
                                </div>
                                <div class="class-body" style="background-color: ${classColorData.body}; padding: 3px 6px; margin: 0 -6px -6px -6px; border-radius: 0 0 5px 5px; font-size: 10px; line-height: 1.2; color: white;">
                                    <div class="class-details" style="color: white;"><strong>${teacherName}</strong> ‚Ä¢ <span class="room-indicator${hasRoomConflict ? ' conflict' : ''}" title="${hasRoomConflict ? 'Room conflict in this slot' : ''}">${roomNameAbbrev}</span> ‚Ä¢ ${classInfo.student_count || 0} students</div>
                                </div>
                            `;
                            cell.appendChild(classBlock);
                        });
                    }
                    
                    row.appendChild(cell);
                });
                
                scheduleRows.appendChild(row);
            });
            
            // After rendering, show a concise room conflict summary
            let totalRoomConflicts = 0;
            const items = [];
            for (const [key, rooms] of conflictMap.entries()) {
                for (const [room, info] of rooms.entries()) {
                    if (info.count > 1) {
                        totalRoomConflicts++;
                        const [d, p] = key.split('-');
                        items.push({ day: d, period: parseInt(p, 10), room, classes: info.classes });
                    }
                }
            }
            if (totalRoomConflicts > 0) {
                const summary = document.createElement('div');
                summary.id = 'roomConflictSummary';
                summary.style.marginTop = '10px';
                summary.innerHTML = `
                    <div class="stat-card" style="grid-column: 1 / -1; background: #fff3f3; border: 1px solid #ffcccc;">
                        <div class="stat-number" style="color:#c0392b;">${totalRoomConflicts}</div>
                        <div class="stat-label">Room Conflicts</div>
                    </div>
                    <div style="grid-column: 1 / -1; font-size: 12px; color: #333; padding: 8px 0;">
                        ${items.map(ci => `
                            <div>‚Ä¢ ${ci.day} Period ${ci.period} ‚Äî <strong>${ci.room}</strong> used by ${ci.classes.join(', ')}</div>
                        `).join('')}
                    </div>
                `;
                scheduleStats.parentNode.insertBefore(summary, scheduleStats.nextSibling);
            }

            // Initialize drag and drop functionality after schedule is rendered
            initializeDragAndDrop();
        }
        
        // Helper function to determine class frequency from units
        function getClassFrequency(units) {
            try {
                const unitsNum = parseInt(units) || 8;
                if (unitsNum === 4) return 1;
                if (unitsNum === 8) return 2;
                if (unitsNum === 12) return 3;
                return 1;
            } catch {
                return 1;
            }
        }

        // Drag and Drop Functionality
        let draggedElement = null;
        let validSlots = [];
        
        // Add event listeners for drag and drop after schedule is displayed
        function initializeDragAndDrop() {
            console.log('Initializing drag and drop functionality');
            
            // Remove existing event listeners to avoid duplicates
            document.removeEventListener('dragstart', handleDragStart);
            document.removeEventListener('dragover', handleDragOver);
            document.removeEventListener('dragenter', handleDragEnter);
            document.removeEventListener('dragleave', handleDragLeave);
            document.removeEventListener('drop', handleDrop);
            document.removeEventListener('dragend', handleDragEnd);
            
            // Add drag and drop event listeners
            document.addEventListener('dragstart', handleDragStart);
            document.addEventListener('dragover', handleDragOver);
            document.addEventListener('dragenter', handleDragEnter);
            document.addEventListener('dragleave', handleDragLeave);
            document.addEventListener('drop', handleDrop);
            document.addEventListener('dragend', handleDragEnd);
            
            console.log(`Found ${document.querySelectorAll('.draggable-class').length} draggable classes`);
        }
        
        function handleDragStart(e) {
            if (!e.target.classList.contains('draggable-class')) return;
            
            draggedElement = e.target;
            e.target.style.opacity = '0.5';
            e.target.style.cursor = 'grabbing';
            
            const className = e.target.dataset.className;
            const sessionIndex = parseInt(e.target.dataset.sessionIndex) || 0;
            const currentDay = e.target.dataset.currentDay;
            const currentPeriod = e.target.dataset.currentPeriod;
            
            console.log(`Drag started: ${className} Session ${sessionIndex + 1} from ${currentDay} Period ${currentPeriod}`);
            
            // Get valid slots from backend
            fetch('/api/get_valid_slots', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    class_name: className,
                    session_index: sessionIndex,
                    current_day: currentDay,
                    current_period: parseInt(currentPeriod)
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    validSlots = data.valid_slots;
                    console.log('DEBUG: Received valid slots from backend:', validSlots.length, 'total slots');
                    console.log('DEBUG: Valid slots:', validSlots.filter(slot => slot.valid).map(slot => `${slot.day} P${slot.period}`));
                    console.log('DEBUG: Invalid slots:', validSlots.filter(slot => !slot.valid).map(slot => `${slot.day} P${slot.period} (${slot.conflicts.join(', ')})`));
                    highlightValidSlots();
                } else {
                    console.error('Failed to get valid slots:', data.error);
                    showAlert(`Cannot move class: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error getting valid slots:', error);
                showAlert(`Error checking available slots: ${error.message || error}`, 'error');
            });
        }
        
        function highlightValidSlots() {
            // Reset all cells
            document.querySelectorAll('.drop-zone').forEach(cell => {
                cell.classList.remove('valid-drop', 'invalid-drop', 'current-slot');
            });
            
            validSlots.forEach(slot => {
                const cell = document.querySelector(`[data-day="${slot.day}"][data-period="${slot.period}"]`);
                if (cell) {
                    if (slot.valid) {
                        cell.classList.add('valid-drop');
                        cell.title = `Valid drop location: ${slot.day} Period ${slot.period}`;
                    } else {
                        cell.classList.add('invalid-drop');
                        cell.title = `Cannot drop here: ${slot.conflicts.join(', ')}`;
                    }
                }
            });
            
            // Mark current slot
            if (draggedElement) {
                const currentDay = draggedElement.dataset.currentDay;
                const currentPeriod = draggedElement.dataset.currentPeriod;
                const currentCell = document.querySelector(`[data-day="${currentDay}"][data-period="${currentPeriod}"]`);
                if (currentCell) {
                    currentCell.classList.add('current-slot');
                    currentCell.title = 'Current location';
                }
            }
        }
        
        function handleDragOver(e) {
            e.preventDefault(); // Allow drop
        }
        
        function handleDragEnter(e) {
            if (e.target.classList.contains('drop-zone')) {
                e.target.classList.add('drag-hover');
            }
        }
        
        function handleDragLeave(e) {
            if (e.target.classList.contains('drop-zone')) {
                e.target.classList.remove('drag-hover');
            }
        }
        
        function handleDrop(e) {
            e.preventDefault();
            
            if (!draggedElement) return;
            
            const dropZone = e.target.closest('.drop-zone');
            if (!dropZone) {
                cleanupDragState();
                return;
            }
            
            const newDay = dropZone.dataset.day;
            const newPeriod = dropZone.dataset.period;
            const className = draggedElement.dataset.className;
            const sessionIndex = parseInt(draggedElement.dataset.sessionIndex) || 0;
            
            console.log(`Drop attempted: ${className} Session ${sessionIndex + 1} to ${newDay} Period ${newPeriod}`);
            
            // Check if this is a valid drop location
            const validSlot = validSlots.find(slot => 
                slot.day === newDay && slot.period == newPeriod
            );
            
            console.log('DEBUG: Looking for slot:', newDay, 'P' + newPeriod);
            console.log('DEBUG: Found valid slot:', validSlot);
            console.log('DEBUG: Total validSlots available:', validSlots.length);
            console.log('DEBUG: All validSlots:', validSlots.map(s => `${s.day} P${s.period} (${s.valid ? 'VALID' : 'INVALID'})`));
            
            if (!validSlot || !validSlot.valid) {
                const reason = !validSlot ? 'slot not found in valid slots list' : 'slot marked as invalid due to conflicts: ' + validSlot.conflicts.join(', ');
                console.log('DEBUG: Drop rejected because:', reason);
                showAlert(`Cannot move session to this location due to conflicts (${reason})`, 'error');
                cleanupDragState();
                return;
            }
            
            // Move the session via backend
            fetch('/api/move_class', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    class_name: className,
                    session_index: sessionIndex,
                    new_day: newDay,
                    new_period: parseInt(newPeriod),
                    // send the original location to let server precisely remove the correct session
                    current_day: draggedElement.dataset.currentDay,
                    current_period: parseInt(draggedElement.dataset.currentPeriod)
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Class moved successfully:', data.new_assignment);
                    
                    // Check if draggedElement is still valid
                    if (!draggedElement) {
                        console.error('draggedElement is null during move success');
                        showAlert('Error: Lost reference to dragged element', 'error');
                        return;
                    }
                    
                    // Update room indicator (preserved room is returned by backend)
                    const roomIndicator = draggedElement.querySelector('.room-indicator');
                    if (roomIndicator && data.new_assignment) {
                        if (data.new_assignment.room) {
                            roomIndicator.textContent = `Room: ${data.new_assignment.room}`;
                        }
                        if (data.new_assignment.room_conflict) {
                            roomIndicator.style.color = '#ff4444';
                            roomIndicator.title = 'Room conflict - check Select Classes page';
                        } else {
                            roomIndicator.style.color = '';
                            roomIndicator.title = '';
                        }
                    }
                    
                    // Move the element in the DOM
                    if (dropZone && dropZone.parentNode) {
                        dropZone.appendChild(draggedElement);
                    }
                    
                    // Update the dragged element's data attributes
                    draggedElement.dataset.currentDay = newDay;
                    draggedElement.dataset.currentPeriod = newPeriod;
                    
                    // Sync with dropdown menus
                    syncDropdowns(className, sessionIndex, newDay, newPeriod);
                    
                    showAlert(`${className} Session ${sessionIndex + 1} moved to ${newDay} Period ${newPeriod}`, 'success');
                } else {
                    console.error('Failed to move class:', data.error);
                    showAlert(`Failed to move class: ${data.error}`, 'error');
                }
                
                // Clean up drag state after successful or failed move
                cleanupDragState();
            })
            .catch(error => {
                console.error('Error moving class:', error);
                showAlert(`Error moving class: ${error.message || error}`, 'error');
                
                // Clean up drag state after error
                cleanupDragState();
            });
        }
        
        function cleanupDragState() {
            // Clear visual feedback
            document.querySelectorAll('.drop-zone').forEach(cell => {
                cell.classList.remove('valid-drop', 'invalid-drop', 'current-slot', 'drag-hover');
                cell.title = '';
            });
            
            // Reset dragged element opacity and cursor
            if (draggedElement) {
                draggedElement.style.opacity = '1';
                draggedElement.style.cursor = 'grab';
            }
            
            draggedElement = null;
            validSlots = [];
        }
        
        function handleDragEnd(e) {
            // Only reset visual state, don't clean up drag state yet
            // (drag state will be cleaned up after move operation completes)
            if (e.target === draggedElement) {
                e.target.style.opacity = '1';
                e.target.style.cursor = 'grab';
            }
        }
        
        // Sync with dropdown menus on the Select Classes page
        function syncDropdowns(className, sessionIndex, newDay, newPeriod) {
            // Find the dropdown for the specific session of this class
            const daySelect = document.querySelector(`select[data-class="${className}"][data-session="${sessionIndex}"][data-field="day"]`);
            const periodSelect = document.querySelector(`select[data-class="${className}"][data-session="${sessionIndex}"][data-field="period"]`);
            
            if (daySelect) {
                daySelect.value = newDay;
                console.log(`Updated day dropdown for ${className} Session ${sessionIndex + 1} to ${newDay}`);
            }
            
            if (periodSelect) {
                periodSelect.value = newPeriod;
                console.log(`Updated period dropdown for ${className} Session ${sessionIndex + 1} to ${newPeriod}`);
            }
        }

        async function exportPDF() {
            if (!currentSchedule) {
                showAlert('No schedule to export', 'error');
                return;
            }
            
            try {
                showAlert('Generating PDF...', 'info');
                console.log('Starting PDF export...');
                
                const response = await fetch('/export_pdf', {
                    method: 'GET'
                });
                
                console.log('Response received:', response.status, response.statusText);
                console.log('Response headers:', [...response.headers.entries()]);
                
                if (response.ok) {
                    // Check if it's a JSON error response
                    const contentType = response.headers.get('content-type');
                    console.log('Content-Type:', contentType);
                    
                    if (contentType && contentType.includes('application/json')) {
                        console.log('Received JSON error response');
                        const result = await response.json();
                        console.log('Error result:', result);
                        showAlert(result.error || 'Export failed', 'error');
                        return;
                    }
                    
                    // Success - download the file
                    console.log('Creating blob from response...');
                    const blob = await response.blob();
                    console.log('Blob created, size:', blob.size, 'type:', blob.type);
                    
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    
                    // Get filename from Content-Disposition header or use default
                    const disposition = response.headers.get('Content-Disposition');
                    let filename = 'class_schedule.pdf';
                    if (disposition && disposition.includes('filename=')) {
                        filename = disposition.split('filename=')[1].replace(/"/g, '');
                    }
                    
                    console.log('Downloading file:', filename);
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    showAlert('Schedule exported successfully!', 'success');
                } else {
                    console.log('Response not OK, status:', response.status);
                    // Try to get error message from response
                    try {
                        const errorResult = await response.json();
                        console.log('Error response JSON:', errorResult);
                        showAlert(errorResult.error || 'Export failed', 'error');
                    } catch (parseError) {
                        console.log('Failed to parse error response as JSON:', parseError);
                        showAlert(`Export failed with status: ${response.status}`, 'error');
                    }
                }
            } catch (error) {
                console.error('Export error details:', error);
                showAlert('Export failed: ' + error.message, 'error');
            }
        }
    </script>
</body>
</html>
